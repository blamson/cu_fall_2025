---
title: "Hw08 - Geostatistics Homework (Prediction)"
format: html
self-contained: true
author: Brady Lamson
date: 11/5/2025
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
packages <- c("dplyr", "sf", "geoR", "gstat", "ggplot2")

for (pkg in packages) {
  if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
    install.packages(pkg, repos = "https://cran.rstudio.com/")
    library(pkg, character.only = TRUE)
  }
}

```


The `cow.rda` file contains a data frame with 200 spatial observations observed throughout the state of Colorado.  The data frame includes `easting` and `northing` coordinates (UTM, scaled by 1000 meters) and Tungsten measurements (`W`) at each site (mg/kg). Read in the data as a data frame from the file.  

# Preliminaries

Load the **gstat** and **geoR** packages. Load the `cow.rda` file.

```{r}
load("cow.rda")
```


# Problem 0

Create `cow_sf`, an `sf` version of `cow` that uses `easting` and `northing` for `coords`. 

Create `geocow`, a `geodata` object from the **geoR** package.


Also run the following code.

```{r}
set.seed(1)
poly_sf <- sf::st_polygon(x = list(cbind(
  c(152, 152, 753, 753, 152),
  c(4100, 4544, 4544, 4100, 4100))))

grid_sf <- sf::st_sample(poly_sf, size = 100,
                         type = "regular")
```

**Solution**

```{r}
cow_sf <- sf::st_as_sf(cow, coords = c("easting", "northing"))
geocow <- geoR::as.geodata(cow)
```

# Problem 1 (Using geoR)

Use REML estimation with a constant mean function to fit the following covariance models to the data:

a. An isotropic spherical model.
b. A geometric anisotropic spherical model.
c. An isotropic exponential model.
d. A geometric anisotropic exponential model.

Make a table that provides the following information about each model: model, partial sill ($c$), range parameter ($a$ or $a_{min}$), nugget ($c_0$), direction of the major axis in degrees, (if appropriate), anisotropy ratio $a_{max}/a_{min}$, AIC of the fit.

Note: starting values make a HUGE difference for the anisotropic models, so you probably want to experiment a bit.

Which model is the best choice?

**Solution**

```{r}
#| code-fold: true
#| code-summary: All the model code
# SPHERICAL ---

# Throw annoying console output into a temporary file to ACTUALLY hide it
sink(tempfile())
# ini cov pars: c(partial sill, range)
lfita = likfit(geocow, ini.cov.pars = c(6000, 50),
               nugget = 1000,
               cov.model = "spherical",
               lik.method = "REML")

lfitb = likfit(geocow, ini.cov.pars = c(1, 10),
               nugget = 1,
               cov.model = "spherical",
               lik.method = "REML",
               psiA = pi/2, psiR = 1,
               fix.psiR = FALSE, fix.psiA = FALSE)

# EXPONENTIAL ---

lfitc = likfit(geocow, ini.cov.pars = c(1, 10),
               nugget = 1,
               cov.model = "exponential",
               lik.method = "REML")

lfitd = likfit(geocow, ini.cov.pars = c(1, 5),
               nugget = 0,
               cov.model = "exponential",
               lik.method = "REML",
               psiA = pi/2, psiR = 1,
               fix.psiR = FALSE, fix.psiA = FALSE)

# flush temp file down the proverbial toilet
sink()
```


|Model|Partial Sill|Range|Nugget|AIC|Anisotropy Angle (degrees)|Anisotropy Ratio|
|---|---|---|---|---|---|---|
|A|1.162|19.26|0|595.2|na|na|
|B|1.089|15.3|0.061|574.2|127|22.72|
|C|1.156|5.917|0|598.2|na|na|
|D|1.161|6.522|0|580.7|127|23.56|

According to AIC, model b performs the best. That is the geometric anisotropic spherical model.

# Problem 2

Create two `gstat` objects with a constant mean and the directional semivariogram model that matches the REML fit provided below. For the first, assume the nugget is microscale error (standard kriging) while the second is measurement error (filtered kriging).

Reminder: **gstat** and **geoR** parameterize the angle and ratio of the $a_{minor}$ and $a_{major}$ differently, so carefully read the documentation. 

```
Summary of the parameter estimation
-----------------------------------
Estimation method: restricted maximum likelihood 

Parameters of the mean component (trend):
  beta 
0.9343 

Parameters of the spatial component:
   correlation function: exponential
      (estimated) variance parameter sigmasq (partial sill) =  1.158
      (estimated) cor. fct. parameter phi (range parameter)  =  3.276
   anisotropy parameters:
      (fixed) anisotropy angle = 0.7854  ( 45.0001052295748 degrees )
      (fixed) anisotropy ratio = 2

Parameter of the error component:
      (estimated) nugget =  0.102

Transformation parameter:
      (fixed) Box-Cox parameter = 1 (no transformation)

Practical Range with cor=0.05 for asymptotic range: 9.812505

Maximised Likelihood:
   log.L n.params      AIC      BIC 
"-296.1"      "4"  "600.1"  "613.3" 

non spatial model:
   log.L n.params      AIC      BIC 
"-297.6"      "2"  "599.1"  "605.7" 

Call:
likfit(geodata = geocow, ini.cov.pars = c(0.5, 10), fix.nugget = FALSE, 
    nugget = 0.1, fix.psiA = TRUE, psiA = pi/4, fix.psiR = TRUE, 
    psiR = 2, cov.model = "exponential", lik.method = "REML", 
    messages = FALSE)
```

**Solution**

```{r}

# This will be our guide for converting from geoR output to gstat
# vgm(c, "model", amax = amin * psiR, c0),
#     anis = c(angle, 1/psiR = amin/amax)

# geoR REML parameters taken directly from above fit
psill_geoR <- 1.158     # c
range_geoR <- 3.276     # amin
nugget_geoR <- 0.102    # c0
psiA_geoR <- 45         # angle
psiR_geoR <- 2          # ratio
amax <- range_geoR * psiR_geoR


# Build the two gstat objects (no fit)
# 1) microscale error: ordinary kriging
gstat_ord <- gstat(
    id = "W", formula = W ~ 1, data = cow_sf,
    model = vgm(
        psill = psill_geoR, 
        model = "Exp", 
        range = range_geoR, 
        nugget = nugget_geoR, 
        anis = c(psiA_geoR, 1/psiR_geoR)
    )
)

gstat_filt <- gstat(
    id = "W", formula = W ~ 1, data = cow_sf,
    model = vgm(
        psill = psill_geoR, 
        model = "Exp", 
        range = range_geoR, 
        Err = nugget_geoR, 
        anis = c(psiA_geoR, 1/psiR_geoR)
    )
)

```


# Problem 3

Perform standard kriging at the locations contained in `grid_sf` using the `gstat` object created in the previous problem.

Use the `summary` function to summarize your results.

**Solution**

```{r}
# ordinary kriging predictions
ok <- predict(gstat_ord, data=cow_sf, newdata = grid_sf)
summary(ok)
```

# Problem 4

Perform filtered kriging at the locations contained in `grid_sf` using the `gstat` object created in Problem 2.

Use the `summary` function to summarize your results.

**Solution**

```{r}
# filtered ordinary kriging
fok <- predict(gstat_filt, data=cow_sf, newdata = grid_sf)
summary(fok)
```

# Problem 5

Are the predictions for standard and filtered kriging identical for the predictions above? Why?

**Solution**

```{r}
head(ok$W.pred, 10)
```

```{r}
head(fok$W.pred, 10)
```


The predictions are identical but the variances are not (we'll look at those later). 

(from the book and slides, horribly paraphrased)

Consider that we can write the process as:

$$
Z(s) = S(s) + \epsilon(s)
$$

Where $S(s)$ is the true noiseless version of the process we're studying and $\epsilon(s)$ is a process representing measurement error.  Standard ordinary kriging predicts $Z(s)$ whereas filtered ordinary kriging seeks to predict $S(s)$, a less noisy process. However these are extremely similar and result in identical predictions, but different variances.

To be totally honest I have zero confidence in that explanation. I tried reading the books explanation on this multiple times and it kept going over my head.

# Problem 6

Create side-by-side plots of the kriging variances from Problems 3 and 4 with a common color scale. Which variances are higher?

**Solution**

```{r}

# Find the overall range of W.var across both datasets
lims <- range(c(ok$W.var, fok$W.var), na.rm = TRUE)

# Plot 1: Ordinary Kriging Variance
p1 <- ggplot(ok) +
  geom_sf(aes(col = W.var)) +
  scale_color_viridis_c(limits = lims) +
  ggtitle("Ordinary Kriging Variance")

# Plot 2: Filtered Ordinary Kriging Variance
p2 <- ggplot(fok) +
  geom_sf(aes(col = W.var)) +
  scale_color_viridis_c(limits = lims) +
  ggtitle("Filtered Ordinary Kriging Variance")

# Can use this for side by side plots i suppose
library(patchwork)
p1 + p2 + plot_layout(guides = "collect")


```

The ordinary kriging variances are higher which is what we would expect. 

# Problem 7

Perform standard kriging at the locations contained in `cow_sf` using the `gstat` object created in Problem 2.

Use the `summary` function to summarize your results.

**Solution**

```{r}
# filtered ordinary kriging
ok2 <- predict(gstat_ord, newdata = cow_sf)
summary(ok2)
```

# Problem 8

Perform filtered kriging at the locations contained in `cow_sf` using the `gstat` object created in Problem 2.

Use the `summary` function to summarize your results.

**Solution**

```{r}
# filtered ordinary kriging
fok2 <- predict(gstat_filt, newdata = cow_sf)
summary(fok2)
```

# Problem 9

Are the standard and unfiltered kriging predictions the same at the observed data locations? Why?

**Solution**

The predictions are not the same this time. Let's check a few examples.

```{r}
head(cow$W, 10)

head(ok2$W.pred, 10)

head(fok2$W.pred, 10)
```


We can think back to our previous explanation here. Since we're predicting on the information we fit the models to, the ordinary kriging is just going to return those exact values with 0 variance. The filtered ordinary kriging however is trying to predict the true noiseless process at these points, so there is still a random element here as it has to handle the measurement error.

# Problem 10

What do you notice about the kriging variances for the filtered and unfilted kriging predictions at observed data locations?

**Solution**

I touched on this in problem 9, but the ordinary kriging has 0 variance for these predictions. It simply returns the original data point. The filtered process has some variance due to the measurement error. The $w$ at a specific point has some implied measurement error that makes the true process random, making the variance for the filtered predictions nonzero. 
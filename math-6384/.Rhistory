for (n in 1:N) {
x <- runif(1, 0, 1)
y <- runif(1, 0, 1)
# obs[n] <- c(x,y)
}
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- c()
for (n in 1:N) {
x <- runif(1, 0, 1)
y <- runif(1, 0, 1)
# obs[n] <- c(x,y)
}
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- list()
for (n in 1:N) {
x <- runif(1, 0, 1)
y <- runif(1, 0, 1)
obs[n] <- c(x,y)
}
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- list()
for (n in 1:N) {
x <- runif(1, 0, 1)
y <- runif(1, 0, 1)
coordinates <- c(x,y)
print(coordinates)
# obs[n] <- c(x,y)
}
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- list()
for (n in 1:N) {
x <- runif(1, 0, 1)
y <- runif(1, 0, 1)
obs[n] <- c(x,y)
}
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- matrix(
runif(2*2, min=1, max=1), ncol=2
)
obs
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- matrix(
runif(2*N, min=1, max=1), ncol=2
)
N
obs
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- matrix(
runif(2*N, min=0, max=1), ncol=2
)
obs
obs[1]
obs[1,]
obs[,1]
library(spatstat)
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- matrix(
runif(2*N, min=0, max=1), ncol=2
)
spatstat.geom::ppp(obs[,1], obs[,2])
library(spatstat)
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- matrix(
runif(2*N, min=0, max=1), ncol=2
)
ppp_object <- spatstat.geom::ppp(obs[,1], obs[,2])
print(ppp_object)
library(spatstat)
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- matrix(
runif(2*N, min=0, max=1), ncol=2
)
ppp_object <- spatstat.geom::ppp(obs[,1], obs[,2])
plot(ppp_object)
library(spatstat)
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- matrix(
runif(2*N, min=0, max=1), ncol=2
)
ppp_object <- spatstat.geom::ppp(obs[,1], obs[,2])
plot(ppp_object)
library(spatstat)
lambda <- 50
N <- rpois(1, lambda)
# N <- 10
obs <- matrix(
runif(2*N, min=0, max=1), ncol=2
)
ppp_object <- spatstat.geom::ppp(obs[,1], obs[,2])
plot(ppp_object)
library(spatstat)
rcsr <- function(lambda = 1) {
N <- rpois(1, lambda)
obs <- matrix(runif(2*N, min=0, max=1), ncol=2)
return(spatstat.geom::ppp(obs[,1], obs[,2]))
}
ppp_object <- rcsr(50)
plot(ppp_object)
library(spatstat)
rcsr <- function(lambda = 1) {
N <- rpois(1, lambda)
obs <- matrix(runif(2*N, min=0, max=1), ncol=2)
return(spatstat.geom::ppp(obs[,1], obs[,2]))
}
ppp_object <- rcsr(50)
plot(ppp_object)
library(spatstat)
rcsr <- function(lambda = 1) {
N <- rpois(1, lambda)
obs <- matrix(runif(2*N, min=0, max=1), ncol=2)
return(spatstat.geom::ppp(obs[,1], obs[,2]))
}
ppp_object <- rcsr(50)
plot(ppp_object)
library(spatstat)
set.seed(100)
rcsr <- function(lambda = 1) {
N <- rpois(1, lambda)
obs <- matrix(runif(2*N, min=0, max=1), ncol=2)
return(spatstat.geom::ppp(obs[,1], obs[,2]))
}
ppp_object <- rcsr(50)
plot(ppp_object)
library(spatstat)
set.seed(100)
rcsr <- function(lambda = 1) {
N <- rpois(1, lambda)
obs <- matrix(runif(2*N, min=0, max=1), ncol=2)
return(spatstat.geom::ppp(obs[,1], obs[,2]))
}
ppp_object <- rcsr(50)
plot(ppp_object)
library(spatstat)
set.seed(100)
rcsr <- function(lambda = 1) {
N <- rpois(1, lambda)
obs <- matrix(runif(2*N, min=0, max=1), ncol=2)
return(spatstat.geom::ppp(obs[,1], obs[,2]))
}
ppp_object <- rcsr(50)
plot(ppp_object)
# 1.
ppp_object <- rcsr(lambda=50)
plot(density(ppp_object))
# 1.
ppp_object <- rcsr(lambda=50)
plot(density(ppp_object))
# 1.
ppp_object <- rcsr(lambda=50)
plot(density(ppp_object))
# 1.
ppp_object <- rcsr(lambda=50)
plot(density(ppp_object))
# 1.
ppp_object <- rcsr(lambda=50)
density(ppp_object)$v
# 1.
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
obs_diff <- max(obs_intensity) - min(obs_intensity)
obs_diff
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object)$v
obs_diff_1 <- max(obs_intensity) - min(obs_intensity)
# 2.
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
obs_diff <- max(obs_intensity) - min(obs_intensity)
obs_diff_1
obs_diff
set.seed(1)
Tobs = 4
# N = 10
# test statistic is (sample mean - 0)/(sd(data)/sqrt(N))
set.seed(1)
Tobs = 4
N = 10 # sample size
nsim = 999 # number of simulated data sets
# Under H0, say the distribution of the data is N(0, 1)
# Simulate data sets under H0
simdata = matrix(rnorm(N * nsim, mean = 0, sd = 1),
nrow = nsim, ncol = N)
# calculate test statistic for each simulated data set
Tsim = rowMeans(simdata)/(apply(simdata, 1, sd)/sqrt(N))
# plot approximate null distribution
plot(density(Tsim))
abline(v = 4) # location of Tobs
# include observed test statistic to simulated test statistics
Tsim = c(Tsim, Tobs)
# determine proportion of test statistics as extreme as the observed
# test statistic
mean(Tsim >= Tobs)
simdata
str(simdata)
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object)$v
library(spatstat)
set.seed(105)
h1 <- rpoispp(50)
print(h1)
plot(h1)
#| code-fold: true
#| code-summary: The code
#|
library(spatstat)
set.seed(100)
rcsr <- function(lambda = 1) {
N <- rpois(1, lambda)
obs <- matrix(runif(2*N, min=0, max=1), ncol=2)
return(spatstat.geom::ppp(obs[,1], obs[,2]))
}
ppp_object <- rcsr(lambda=50)
plot(ppp_object)
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_1 <- max(obs_intensity) - min(obs_intensity)
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_1 <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_obs <- c()
for (i in 1:sims) {
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
t_temp <- max(obs_intensity) - min(obs_intensity)
t_obs[i] <- t_temp
}
sims %% 100
sims %% 10
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_1 <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_obs <- c()
for (i in 1:sims) {
if (i %% sims/4 == 0 ) {
cat("Iteration:", i)
}
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
t_temp <- max(obs_intensity) - min(obs_intensity)
t_obs[i] <- t_temp
}
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_1 <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_obs <- c()
for (i in 1:sims) {
if (i %% (sims/4) == 0 ) {
cat("Iteration:", i)
}
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
t_temp <- max(obs_intensity) - min(obs_intensity)
t_obs[i] <- t_temp
}
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_1 <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_obs <- c()
for (i in 1:sims) {
if (i %% (sims/4) == 0 ) {
cat("Iteration:", i, "\n")
}
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
t_temp <- max(obs_intensity) - min(obs_intensity)
t_obs[i] <- t_temp
}
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_1 <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_obs <- c()
progressbar <- txtProgressBar(min=0, max=sims, style=3)
for (i in 1:sims) {
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
t_temp <- max(obs_intensity) - min(obs_intensity)
t_obs[i] <- t_temp
seeTxtProgressBar(progressbar, i)
}
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_1 <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_obs <- c()
progressbar <- txtProgressBar(min=0, max=sims, style=3)
for (i in 1:sims) {
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
t_temp <- max(obs_intensity) - min(obs_intensity)
t_obs[i] <- t_temp
setTxtProgressBar(progressbar, i)
}
t_obs
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_obs <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_sim <- c()
progressbar <- txtProgressBar(min=0, max=sims, style=3)
for (i in 1:sims) {
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
t_temp <- max(obs_intensity) - min(obs_intensity)
t_sim[i] <- t_temp
setTxtProgressBar(progressbar, i)
}
# Compute p-value
mean(t_sim >= t_obs)
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_obs <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_sim <- numeric(sims)
progressbar <- txtProgressBar(min=0, max=sims, style=3)
for (i in 1:sims) {
ppp_object <- rcsr(lambda=50)
obs_intensity <- density(ppp_object)$v
t_temp <- max(obs_intensity) - min(obs_intensity)
t_sim[i] <- t_temp
setTxtProgressBar(progressbar, i)
}
# Compute p-value
sum(t_sim >= t_obs + 1) / (sims + 1)
mean(t_sim >= t_obs)
# Compute p-value
(sum(t_sim >= t_obs) + 1) / (sims + 1)
plot(density(t_sim),
main = "Monte Carlo Test Statistic Distribution",
xlab = "Max - Min Intensity")
abline(v = t_obs, col = "red", lty = 2, lwd = 2)
# Compute p-value
p_value <- (sum(t_sim >= t_obs) + 1) / (sims + 1)
cat("Monte Carlo P-Value:", p_value)
#| code-fold: true
#| code-summary: The code
library(pbapply)
install.packages("pbapply")
#| code-fold: true
#| code-summary: The code
library(pbapply)
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_obs <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_sim <- numeric(sims)
progressbar <- txtProgressBar(min=0, max=sims, style=3)
# for (i in 1:sims) {
#     ppp_object <- rcsr(lambda=50)
#     obs_intensity <- density(ppp_object)$v
#     t_temp <- max(obs_intensity) - min(obs_intensity)
#     t_sim[i] <- t_temp
#     setTxtProgressBar(progressbar, i)
# }
t_sim <- pbapply::pbsapply(1:sims, function(i) {
sim <- rcsr(lambda = 50)
dens <- density(sim)
max(dens$v) - min(dens$v)
})
# Compute p-value
p_value <- (sum(t_sim >= t_obs) + 1) / (sims + 1)
cat("Monte Carlo P-Value:", p_value)
# Compute p-value
p_value <- (sum(t_sim >= t_obs) + 1) / (sims + 1)
cat("Monte Carlo P-Value:", p_value)
#| code-fold: true
#| code-summary: Make a plot for my own sake
plot(density(t_sim),
main = "Monte Carlo Test Statistic Distribution",
xlab = "Max - Min Intensity")
abline(v = t_obs, col = "red", lty = 2, lwd = 2)
#| code-fold: true
#| code-summary: The code
library(pbapply)
set.seed(500)
# 1.
ppp_object_1 <- spatstat.random::rpoispp(lambda=50)
obs_intensity_1 <- density(ppp_object_1)$v
t_obs <- max(obs_intensity_1) - min(obs_intensity_1)
# 2 and 3.
sims <- 1000
t_sim <- numeric(sims)
progressbar <- txtProgressBar(min=0, max=sims, style=3)
t_sim <- pbapply::pbsapply(1:sims, function(i) {
sim <- rcsr(lambda = 50)
i_sim <- density(sim)$v
max(i_sim) - min(i_sim)
})
# Compute p-value
p_value <- (sum(t_sim >= t_obs) + 1) / (sims + 1)
cat("Monte Carlo P-Value:", p_value)
#| code-fold: true
#| code-summary: Make a plot for my own sake
plot(density(t_sim),
main = "Monte Carlo Test Statistic Distribution",
xlab = "Max - Min Intensity")
abline(v = t_obs, col = "red", lty = 2, lwd = 2)
mydata <- spatstat.data::japanesepines
mydata
plot(mydata)
spatstat.explore::bw.scott(mydata)
bandwidth <- spatstat.explore::bw.scott(mydata)
bandwidth$sigma.x
str(bandwidth)
bandwidth[1]
bandwidth[1] + 1
bandwidth[1]
bandwidth[1][0]
bandwidth[1][1]
bandwidth[1]
spdensity()
library(spatstat) # for inference on spatial point processes
library(smacpod)
data(grave, package = "smacpod") # import data in ppp format
# determine affected and unaffected sides
af <- which(grave$marks == "affected")
un <- which(grave$marks == "unaffected")
# plot of event locations
plot(grave)
# recommended bandwidths for affected and unaffected graves
# in u- and v-directions
dim <- 2
# Scott's bandwidths in u- and v-directions
# for each group
buaf <- sd(grave$x[af])*length(af)^(-1/(dim+4))
bvaf <- sd(grave$y[af])*length(af)^(-1/(dim+4))
buun <- sd(grave$x[un])*length(un)^(-1/(dim+4))
bvun <- sd(grave$y[un])*length(un)^(-1/(dim+4))
# or
bw.scott(grave[af,])
c(buaf, bvaf)
bw.scott(grave[un,])
# density estimated for affected and unaffected groups
# using associated bandwidths from Scott's rule
daf <-  spdensity(grave[af,], sigma = c(buaf, bvaf))
dun <-  spdensity(grave[un,], sigma = c(buun, bvun))
# plot perspective and contour plots of estimated density for affected sites
par(mfrow = c(1, 2))
contour(daf, xlab = "u", ylab = "v", main = "Affected grave locations")
points(grave, pch = ".")
# plot perspective and contour plots of estimated density for unaffected sites
par(mfrow = c(1, 2))
persp(dun, theta = 45, phi = 35, xlab = "u", ylab = "v", zlab = "density", main = "Estimated intensity function")
contour(dun, xlab = "u", ylab = "v", main = "Unaffected grave locations")
points(grave, pch = ".")
# plot perspective and contour plots of estimated density for unaffected sites
par(mfrow = c(1, 2))
contour(daf, xlab = "u", ylab = "v", main = "Affected")
points(grave, pch = ".")
contour(dun, xlab = "u", ylab = "v", main = "Unaffected")
points(grave, pch = ".")
par(mfrow = c(1, 1))
mydata
bandwidth <- spatstat.explore::bw.scott(mydata)
intensity_est <- density(mydata, sigma=bandwidth)
contour(intensity_est)
bandwidth <- spatstat.explore::bw.scott(mydata)
intensity_est <- density(mydata, sigma=bandwidth)
contour(intensity_est)
mydata <- spatstat.data::japanesepines
plot(mydata)
bandwidth <- spatstat.explore::bw.scott(mydata)
intensity_est <- density(mydata, sigma=bandwidth)
intensity_est <- spdensity(mydata, sigma = bandwidth)
contour(intensity_est)

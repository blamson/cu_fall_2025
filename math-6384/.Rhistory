#| code-fold: true
#| code-summary: The code
set.seed(500)
h <- seq(from=0, to=0.25, length.out=200)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(pines, r=h, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - h) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(pines),
win = spatstat.geom::Window(pines)
)
sim_L <- spatstat.explore::Lest(sim_data, r=h, correction = "Ripley")
max( abs(sim_L$iso - h) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
#| code-fold: true
#| code-summary: Make a plot for my own sake
plot(density(Tsim),
xlim = range(c(Tsim, Tobs)),
main = "Monte Carlo Test Statistic Distribution",
xlab = "T")
abline(v = Tobs, col = "red", lty = 2, lwd = 2)
redwood <- spatstat.data::redwood
plot(redwood)
bandwidth <- spatstat.explore::bw.scott(redwood)
intensity_est <- smacpod::spdensity(redwood, sigma = bandwidth)
contour(intensity_est)
lplot(redwood)
#| code-fold: true
#| code-summary: Exact same code as last time.
set.seed(500)
h <- seq(from=0, to=0.25, length.out=200)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(redwood, r=h, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - h) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(redwood),
win = spatstat.geom::Window(redwood)
)
sim_L <- spatstat.explore::Lest(sim_data, r=h, correction = "Ripley")
max( abs(sim_L$iso - h) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
set.seed(1)
x <- runif(15) # runif defaults to min=0, max=1
h <- seq(-1, 2, len = 1000)
#| code-fold: true
#| code-summary: Code
# (i) Evaluate Gaussian kernel (sd = 0.1) at each event location
# Object is 1000 rows by 15 columns
kernels <- sapply(x, function(xi) dnorm(h, mean = xi, sd = 0.10))
# (ii) Sum across rows
kernel_sums <- rowSums(kernels)
plot(x=h, y=kernel_sums, type="l", lwd=2)
# Use matlines here for easily showing all of the lines on the plot at once without calling lines() a ton.
matlines(h, kernels, lty = 1, col = "darkgrey")
#| code-fold: true
#| code-summary: Same code
#|
kernels <- sapply(x, function(xi) dnorm(h, mean = xi, sd = 0.25))
kernel_sums <- rowSums(kernels)
plot(x=h, y=kernel_sums, type="l", lwd=2)
matlines(h, kernels, lty = 1, col = "darkgrey")
#| code-fold: true
#| code-summary: Exact same code as last time.
set.seed(500)
h <- seq(from=0, to=0.25, length.out=200)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(redwood, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - h) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(redwood),
win = spatstat.geom::Window(redwood)
)
sim_L <- spatstat.explore::Lest(sim_data, correction = "Ripley")
max( abs(sim_L$iso - h) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
#| code-fold: true
#| code-summary: Exact same code as last time.
set.seed(500)
h <- seq(from=0, to=0.25, length.out=200)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(redwood, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - h) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(redwood),
win = spatstat.geom::Window(redwood)
)
sim_L <- spatstat.explore::Lest(sim_data, correction = "Ripley")
max( abs(sim_L$iso - h) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
packages <- c("spatstat", "pbapply", "smacpod")
for (pkg in packages) {
if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
install.packages(pkg, repos = "https://cran.rstudio.com/")
library(pkg, character.only = TRUE)
}
}
pines <- spatstat.data::japanesepines
#| code-fold: true
#| code-summary: The code
lplot <- function(x, nsim = 499, level = 0.95,
correction = "Ripley", ...) {
e_outer = envelope(x, fun = spatstat.explore::Lest,
nsim = nsim, nrank = 1,
savepatterns = TRUE)
e_tol = envelope(e_outer, fun = spatstat.explore::Lest,
nsim = nsim,
nrank = floor((1 - level) * (nsim + 1)/2))
plot(e_outer, fmla = . - r ~ r, legend = FALSE, main = "")
plot(e_tol, fmla = . - r ~ r, shadecol = "lightgrey", add = TRUE)
}
lplot(pines)
#| code-fold: true
#| code-summary: The code
set.seed(500)
h <- seq(from=0, to=0.25, length.out=200)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(pines, r=h, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - h) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(pines),
win = spatstat.geom::Window(pines)
)
sim_L <- spatstat.explore::Lest(sim_data, r=h, correction = "Ripley")
max( abs(sim_L$iso - h) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
#| code-fold: true
#| code-summary: Make a plot for my own sake
plot(density(Tsim),
xlim = range(c(Tsim, Tobs)),
main = "Monte Carlo Test Statistic Distribution",
xlab = "T")
abline(v = Tobs, col = "red", lty = 2, lwd = 2)
redwood <- spatstat.data::redwood
plot(redwood)
bandwidth <- spatstat.explore::bw.scott(redwood)
intensity_est <- smacpod::spdensity(redwood, sigma = bandwidth)
contour(intensity_est)
lplot(redwood)
#| code-fold: true
#| code-summary: Exact same code as last time.
set.seed(500)
h <- seq(from=0, to=0.25, length.out=200)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(redwood, r=h, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - h) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(redwood),
win = spatstat.geom::Window(redwood)
)
sim_L <- spatstat.explore::Lest(sim_data, r=h, correction = "Ripley")
max( abs(sim_L$iso - h) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
set.seed(1)
x <- runif(15) # runif defaults to min=0, max=1
h <- seq(-1, 2, len = 1000)
#| code-fold: true
#| code-summary: Code
# (i) Evaluate Gaussian kernel (sd = 0.1) at each event location
# Object is 1000 rows by 15 columns
kernels <- sapply(x, function(xi) dnorm(h, mean = xi, sd = 0.10))
# (ii) Sum across rows
kernel_sums <- rowSums(kernels)
plot(x=h, y=kernel_sums, type="l", lwd=2)
# Use matlines here for easily showing all of the lines on the plot at once without calling lines() a ton.
matlines(h, kernels, lty = 1, col = "darkgrey")
#| code-fold: true
#| code-summary: Same code
#|
kernels <- sapply(x, function(xi) dnorm(h, mean = xi, sd = 0.25))
kernel_sums <- rowSums(kernels)
plot(x=h, y=kernel_sums, type="l", lwd=2)
matlines(h, kernels, lty = 1, col = "darkgrey")
#| code-fold: true
#| code-summary: The code
set.seed(500)
h <- seq(from=0, to=0.25, length.out=200)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(pines, r=h, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - h) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(pines),
win = spatstat.geom::Window(pines)
)
sim_L <- spatstat.explore::Lest(sim_data, r=h, correction = "Ripley")
max( abs(sim_L$iso - h) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
L_obs <- spatstat.explore::Lest(pines, correction = "Ripley")
L_obs
L_obs$r
#| code-fold: true
#| code-summary: The code
set.seed(500)
h <- seq(from=0, to=0.25, length.out=200)
# Break out \hat{L}(h) just for readability
# L_obs <- spatstat.explore::Lest(pines, r=h, correction = "Ripley")
L_obs <- spatstat.explore::Lest(pines, correction = "Ripley")
# Calc observed test statistic across h
# Tobs <- max( abs(L_obs$iso - h) )
Tobs <- max( abs(L_obs$iso - L_obs$r) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(pines),
win = spatstat.geom::Window(pines)
)
# sim_L <- spatstat.explore::Lest(sim_data, r=h, correction = "Ripley")
sim_L <- spatstat.explore::Lest(sim_data, correction = "Ripley")
# max( abs(sim_L$iso - h) )
max( abs(sim_L$iso - sim_L$r) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
#| code-fold: true
#| code-summary: Make a plot for my own sake
plot(density(Tsim),
xlim = range(c(Tsim, Tobs)),
main = "Monte Carlo Test Statistic Distribution",
xlab = "T")
abline(v = Tobs, col = "red", lty = 2, lwd = 2)
#| code-fold: true
#| code-summary: Exact same code as last time.
set.seed(500)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(redwood, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - L-obs$r) )
#| code-fold: true
#| code-summary: Exact same code as last time.
set.seed(500)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(redwood, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - L_obs$r) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(redwood),
win = spatstat.geom::Window(redwood)
)
sim_L <- spatstat.explore::Lest(sim_data, correction = "Ripley")
max( abs(sim_L$iso - sim_L$r) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
packages <- c("spatstat", "pbapply", "smacpod")
for (pkg in packages) {
if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
install.packages(pkg, repos = "https://cran.rstudio.com/")
library(pkg, character.only = TRUE)
}
}
pines <- spatstat.data::japanesepines
#| code-fold: true
#| code-summary: The code
lplot <- function(x, nsim = 499, level = 0.95,
correction = "Ripley", ...) {
e_outer = envelope(x, fun = spatstat.explore::Lest,
nsim = nsim, nrank = 1,
savepatterns = TRUE)
e_tol = envelope(e_outer, fun = spatstat.explore::Lest,
nsim = nsim,
nrank = floor((1 - level) * (nsim + 1)/2))
plot(e_outer, fmla = . - r ~ r, legend = FALSE, main = "")
plot(e_tol, fmla = . - r ~ r, shadecol = "lightgrey", add = TRUE)
}
lplot(pines)
#| code-fold: true
#| code-summary: The code
set.seed(500)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(pines, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - L_obs$r) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(pines),
win = spatstat.geom::Window(pines)
)
sim_L <- spatstat.explore::Lest(sim_data, correction = "Ripley")
max( abs(sim_L$iso - sim_L$r) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
#| code-fold: true
#| code-summary: Make a plot for my own sake
plot(density(Tsim),
xlim = range(c(Tsim, Tobs)),
main = "Monte Carlo Test Statistic Distribution",
xlab = "T")
abline(v = Tobs, col = "red", lty = 2, lwd = 2)
redwood <- spatstat.data::redwood
plot(redwood)
bandwidth <- spatstat.explore::bw.scott(redwood)
intensity_est <- smacpod::spdensity(redwood, sigma = bandwidth)
contour(intensity_est)
lplot(redwood)
#| code-fold: true
#| code-summary: Exact same code as last time.
set.seed(500)
# Break out \hat{L}(h) just for readability
L_obs <- spatstat.explore::Lest(redwood, correction = "Ripley")
# Calc observed test statistic across h
Tobs <- max( abs(L_obs$iso - L_obs$r) )
# Do the same setup for the simulated datasets.
Tsim <- pbapply::pbsapply(1:499, FUN = function(i) {
sim_data <- spatstat.random::rpoispp(
lambda=spatstat.geom::intensity(redwood),
win = spatstat.geom::Window(redwood)
)
sim_L <- spatstat.explore::Lest(sim_data, correction = "Ripley")
max( abs(sim_L$iso - sim_L$r) )
})
# We make sure to include our observed data in the p-value.
p <- mean(c(Tsim, Tobs) >= Tobs)
cat("P-Value:", p)
set.seed(1)
x <- runif(15) # runif defaults to min=0, max=1
h <- seq(-1, 2, len = 1000)
#| code-fold: true
#| code-summary: Code
# (i) Evaluate Gaussian kernel (sd = 0.1) at each event location
# Object is 1000 rows by 15 columns
kernels <- sapply(x, function(xi) dnorm(h, mean = xi, sd = 0.10))
# (ii) Sum across rows
kernel_sums <- rowSums(kernels)
plot(x=h, y=kernel_sums, type="l", lwd=2)
# Use matlines here for easily showing all of the lines on the plot at once without calling lines() a ton.
matlines(h, kernels, lty = 1, col = "darkgrey")
#| code-fold: true
#| code-summary: Same code
#|
kernels <- sapply(x, function(xi) dnorm(h, mean = xi, sd = 0.25))
kernel_sums <- rowSums(kernels)
plot(x=h, y=kernel_sums, type="l", lwd=2)
matlines(h, kernels, lty = 1, col = "darkgrey")
A = matrix(c(1,2,3,0,1,1,1,1), nrow=2)
A
A = matrix(c(1,2,3,0,1,1,1,1), nrow=2, byrow=T)
A
rank(A)
A[1,]
A[,2:3]
N <- A[,c(1,4)]
N
b <- matrix(c(6,4))
b
solve(B)
B <- A[,2:3]
solve(B)
solve(B) %*% b
A = matrix(c(1,2,3,0,1,1,1,1), nrow=2, byrow=T)
B <- A[,2:3]
N <- A[,c(1,4)]
b <- matrix(c(6,4))
basic_solution <- solve(B) %*% b
print(basic_solution)
A <- matrix(c(1,2,3,0,  # row1
1,1,1,1), # row2
nrow=2, byrow=TRUE)
b <- c(6,4)
library(utils) # for combn
cols <- 1:4
cmb <- combn(cols, 2, simplify = FALSE)
results <- lapply(cmb, function(idx){
B <- A[, idx]
if (abs(det(B)) < 1e-10) return(list(basis=idx, feasible=NA, sol=NA, note="singular"))
sol <- solve(B, b)
feasible <- all(sol >= -1e-10) # allow tiny numerical tolerance
list(basis=idx, feasible=feasible, sol=sol)
})
# Print nicely
for (r in results) {
cat("basis columns:", paste(r$basis, collapse=","), "\n")
if (is.character(r$sol)) cat("  ", r$note, "\n") else {
cat("  basic solution:", paste(round(r$sol,6), collapse=", "), "\n")
cat("  feasible (all >=0)?", r$feasible, "\n")
}
}
A = matrix(c(1,2,3,0,1,1,1,1), nrow=2, byrow=T)
B <- A[,2:3]
N <- A[,c(1,4)]
b <- matrix(c(6,4))
basic_solution <- solve(B) %*% b
print(basic_solution) # returns (6, -2)
solve(B)
library(utils) # for combn
# A = matrix(c(1,2,3,0,1,1,1,1), nrow=2, byrow=T)
# B <- A[,2:3]
# N <- A[,c(1,4)]
# b <- matrix(c(6,4))
# basic_solution <- solve(B) %*% b
# print(basic_solution) # returns (6, -2)
#
#
#
# # ---
#
# A <- matrix(c(1,2,3,0,  # row1
#               1,1,1,1), # row2
#             nrow=2, byrow=TRUE)
# b <- c(6,4)
library(utils) # for combn
A = matrix(c(1,2,3,0,1,1,1,1), nrow=2, byrow=T)
cols <- 1:4
cmb <- combn(cols, 2, simplify = FALSE)
results <- lapply(cmb, function(idx){
B <- A[, idx]
if (abs(det(B)) < 1e-10) return(list(basis=idx, feasible=NA, sol=NA, note="singular"))
sol <- solve(B, b)
feasible <- all(sol >= -1e-10) # allow tiny numerical tolerance
list(basis=idx, feasible=feasible, sol=sol)
})
# A = matrix(c(1,2,3,0,1,1,1,1), nrow=2, byrow=T)
# B <- A[,2:3]
# N <- A[,c(1,4)]
# b <- matrix(c(6,4))
# basic_solution <- solve(B) %*% b
# print(basic_solution) # returns (6, -2)
#
#
#
# # ---
#
# A <- matrix(c(1,2,3,0,  # row1
#               1,1,1,1), # row2
#             nrow=2, byrow=TRUE)
# b <- c(6,4)
library(utils) # for combn
A = matrix(c(1,2,3,0,1,1,1,1), nrow=2, byrow=T)
b <- matrix(c(6,4))
cols <- 1:4
cmb <- combn(cols, 2, simplify = FALSE)
results <- lapply(cmb, function(idx){
B <- A[, idx]
if (abs(det(B)) < 1e-10) return(list(basis=idx, feasible=NA, sol=NA, note="singular"))
sol <- solve(B, b)
feasible <- all(sol >= -1e-10) # allow tiny numerical tolerance
list(basis=idx, feasible=feasible, sol=sol)
})
# Print nicely
for (r in results) {
cat("basis columns:", paste(r$basis, collapse=","), "\n")
if (is.character(r$sol)) cat("  ", r$note, "\n") else {
cat("  basic solution:", paste(round(r$sol,6), collapse=", "), "\n")
cat("  feasible (all >=0)?", r$feasible, "\n")
}
}
library(utils) # for combn
A = matrix(c(1,2,3,0,1,1,1,1), nrow=2, byrow=T)
b <- matrix(c(6,4))
cols <- 1:4
cmb <- combn(cols, 2, simplify = FALSE)
results <- lapply(cmb, function(idx){
B <- A[, idx]
if (abs(det(B)) < 1e-10) return(list(basis=idx, feasible=NA, sol=NA, note="singular"))
sol <- solve(B, b)
feasible <- all(sol >= -1e-10) # allow tiny numerical tolerance
list(basis=idx, feasible=feasible, sol=sol)
})
# Print nicely
for (r in results) {
cat("basis columns:", paste(r$basis, collapse=","), "\n")
if (is.character(r$sol)) cat("  ", r$note, "\n") else {
cat("  basic solution:", paste(round(r$sol,6), collapse=", "), "\n")
cat("  feasible (all >=0)?", r$feasible, "\n")
}
}
